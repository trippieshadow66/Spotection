<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stall Config - Lot {{ lot_name }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: #0b1724;
      color: #ecf0f1;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 12px 20px;
      background: #111c2b;
      border-bottom: 1px solid #1f2c3a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    header h1 {
      font-size: 1.25rem;
      font-weight: 600;
    }

    header .meta {
      font-size: 0.9rem;
      opacity: 0.8;
    }

    header .right-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .back-button {
      background: #34495e;
      color: #ecf0f1;
      border: 1px solid #2ecc71;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      text-decoration: none;
      transition: background 0.15s ease, transform 0.05s ease,
        box-shadow 0.05s ease;
    }

    .back-button:hover {
      background: #2ecc71;
      color: #0b1724;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.45);
      transform: translateY(-1px);
    }

    main {
      flex: 1;
      display: flex;
      padding: 12px;
      gap: 12px;
      overflow: hidden;
    }

    .left-panel {
      flex: 3;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 0;
      overflow: auto;
    }

    .right-panel {
      flex: 1.4;
      background: #111c2b;
      border-radius: 10px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      border: 1px solid #1f2c3a;
      max-width: 360px;
    }

    .video-wrapper {
      position: relative;
      background: #000;
      border-radius: 10px;
      border: 1px solid #1f2c3a;
      padding: 6px;
      /* important: no inner scrollbars so coordinates stay stable */
      overflow: visible;
    }
    

    #liveFeed {
      display: block;
      max-width: auto;
      height: auto;
      border-radius: 6px;
    }

    #configCanvas {
      position: absolute;
      left: 6px;
      top: 6px;
      pointer-events: auto;
    }

    .toolbar {
      background: #111c2b;
      border-radius: 10px;
      border: 1px solid #1f2c3a;
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
    }

    label {
      margin-right: 4px;
    }

    select,
    input[type="number"] {
      background: #0b1724;
      color: #ecf0f1;
      border-radius: 6px;
      border: 1px solid #1f2c3a;
      padding: 4px 6px;
      font-size: 0.85rem;
    }

    button {
      background: #2ecc71;
      color: #0b1724;
      border: none;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.05s ease, box-shadow 0.05s ease, opacity 0.2s;
      white-space: nowrap;
    }

    button.secondary {
      background: #34495e;
      color: #ecf0f1;
    }

    button.danger {
      background: #e74c3c;
      color: #fff;
    }

    button:hover {
      opacity: 0.9;
      box-shadow: 0 0 0 1px rgba(236, 240, 241, 0.06),
        0 6px 16px rgba(0, 0, 0, 0.45);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    .right-panel h2 {
      font-size: 1rem;
      margin-bottom: 4px;
    }

    .right-panel p.helper {
      font-size: 0.8rem;
      opacity: 0.8;
      margin-bottom: 4px;
    }

    .stall-list {
      flex: 1;
      overflow: auto;
      border-radius: 8px;
      border: 1px solid #1f2c3a;
      background: #0b1724;
      padding: 4px;
    }

    .stall-item {
      padding: 6px 8px;
      border-radius: 6px;
      margin-bottom: 4px;
      background: #111c2b;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .stall-item span {
      pointer-events: none;
    }

    .stall-item.selected {
      outline: 1px solid #2ecc71;
      background: #13253a;
    }

    .stall-item small {
      opacity: 0.7;
    }

    .right-panel .buttons-row {
      display: flex;
      gap: 6px;
      margin-top: 6px;
    }

    .status-bar {
      font-size: 0.8rem;
      opacity: 0.85;
      margin-top: 2px;
      min-height: 1.2em;
    }

    .status-bar.ok {
      color: #2ecc71;
    }

    .status-bar.error {
      color: #e74c3c;
    }

    @media (max-width: 960px) {
      main {
        flex-direction: column;
      }
      .right-panel {
        max-width: none;
        width: 100%;
        order: -1;
      }
    }
    .right-panel,
    .toolbar,
    button,
    select,
    input,
    .stall-list {
      position: relative;
      z-index: 20;
    }

    .video-wrapper {
      position: relative;
      z-index: 1;
    }

    #liveFeed {
      position: relative;
      z-index: 2;
    }

    #configCanvas {
      position: absolute;
      z-index: 3;
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <header>
    <h1>Stall Configuration – {{ lot_name }}</h1>
    <div class="right-actions">
      <div class="meta">Lot ID: {{ lot_id }}</div>
      <!-- Flip toggle button -->
      <button id="flipToggle" class="secondary" style="padding:6px 10px;">Flip: <span id="flipState">OFF</span></button>

      <a class="back-button" href="/">← Back to Dashboard</a>
    </div>
  </header>

  <main>
    <section class="left-panel">
      <div class="video-wrapper">
        <!-- Live feed background (single photo so pixels match detection frames) -->
        <img
          id="liveFeed"
          src="/frame-latest/{{ lot_id }}"
          alt="Frame for lot {{ lot_name }}"
        />
        <!-- Transparent drawing canvas -->
        <canvas id="configCanvas"></canvas>
      </div>

      <div class="toolbar">
        <div>
          <label for="laneSelect">Lane:</label>
          <input
            type="number"
            id="laneSelect"
            min="1"
            max="50"
            value="1"
            style="width: 60px"
          />
        </div>

        <div>
          <button id="btnUndoPoint" class="secondary">Undo Point</button>
          <button id="btnClearCurrent" class="secondary">
            Clear Current Stall
          </button>
          <button id="btnFinishStall">Finish Stall</button>
        </div>

        <div style="flex: 1; min-width: 180px; font-size: 0.8rem;">
          <strong>How to draw:</strong>
          Click on the image to add corner points of a stall.
          Use <em>Finish Stall</em> when done.
        </div>
      </div>
    </section>

    <section class="right-panel">
      <h2>Stalls</h2>
      <p class="helper">
        Click in the list to select a stall. Selected stall is highlighted on
        the image.
      </p>

      <div id="stallList" class="stall-list"></div>

      <div class="buttons-row">
        <button id="btnDeleteStall" class="danger" style="flex: 1;">
          Delete Selected Stall
        </button>
        <button id="btnSaveConfig" style="flex: 1;">Save Config</button>
      </div>

      <div id="statusBar" class="status-bar"></div>

      <p class="helper">
        When you finish, go back to the dashboard and watch detection start
        using these stalls.
      </p>
    </section>
  </main>

  <script>
    (function () {
      const lotId = {{ lot_id }};
      const apiConfigUrl = `/api/lots/${lotId}/config`;

      let imgEl, canvas, ctx;
      let canvasWidth = 0;
      let canvasHeight = 0;

      // Stall data in UI form: { id, lane, points: [{x,y}, ...] }
      let stalls = [];
      let nextStallId = 1;
      let currentPoints = [];
      let selectedStallId = null;

      function setStatus(message, type) {
        const bar = document.getElementById("statusBar");
        bar.textContent = message || "";
        bar.classList.remove("ok", "error");
        if (type === "ok") bar.classList.add("ok");
        if (type === "error") bar.classList.add("error");
      }

      function setupCanvasFromImage() {
        if (!imgEl.complete || !imgEl.naturalWidth) {
          imgEl.addEventListener("load", setupCanvasFromImage, { once: true });
          return;
        }

        const w = imgEl.naturalWidth;
        const h = imgEl.naturalHeight;
        if (!w || !h) return;

        canvasWidth = w;
        canvasHeight = h;

        // Force DOM size to match the actual pixel size
        imgEl.width = w;
        imgEl.height = h;
        canvas.width = w;
        canvas.height = h;

        drawAll();
      }

      function canvasCoords(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvasWidth / rect.width;
        const scaleY = canvasHeight / rect.height;
        const x = (evt.clientX - rect.left) * scaleX;
        const y = (evt.clientY - rect.top) * scaleY;
        return { x, y };
      }

      function onCanvasClick(evt) {
        const pt = canvasCoords(evt);
        currentPoints.push(pt);
        drawAll();
      }

      function colorForLane(lane) {
        const palette = [
          "#1abc9c",
          "#3498db",
          "#9b59b6",
          "#e67e22",
          "#e74c3c",
          "#f1c40f",
          "#2ecc71",
          "#16a085",
          "#95a5a6",
          "#ff9ff3"
        ];
        const idx =
          typeof lane === "number"
            ? (lane - 1 + palette.length) % palette.length
            : 0;
        return palette[idx];
      }

      function drawPolygon(points, color, isSelected) {
        if (!points || points.length === 0) return;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();

        ctx.lineWidth = isSelected ? 3 : 2;
        ctx.strokeStyle = color;
        ctx.stroke();

        ctx.save();
        ctx.globalAlpha = isSelected ? 0.18 : 0.12;
        ctx.fillStyle = color;
        ctx.fill();
        ctx.restore();
      }

      function drawLabel(points, text) {
        if (!points || points.length === 0) return;
        let cx = 0,
          cy = 0;
        for (const p of points) {
          cx += p.x;
          cy += p.y;
        }
        cx /= points.length;
        cy /= points.length;

        ctx.fillStyle = "#000000aa";
        ctx.beginPath();
        ctx.arc(cx, cy, 10, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#ecf0f1";
        ctx.font = "bold 11px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(text), cx, cy);
      }

      function drawAll() {
        if (!ctx || !canvasWidth || !canvasHeight) return;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        // Existing stalls
        for (const stall of stalls) {
          const color = colorForLane(stall.lane);
          const isSelected = stall.id === selectedStallId;
          drawPolygon(stall.points, color, isSelected);
          drawLabel(stall.points, stall.id);
        }

        // Current in-progress polygon
        if (currentPoints.length > 0) {
          const color = "#ffffff";
          drawPolygon(currentPoints, color, false);

          // Also draw small dots at each click point
          ctx.fillStyle = "#ffffff";
          for (const p of currentPoints) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      function refreshStallList() {
        const container = document.getElementById("stallList");
        container.innerHTML = "";
        stalls
          .slice()
          .sort((a, b) => a.id - b.id)
          .forEach((stall) => {
            const div = document.createElement("div");
            div.className = "stall-item";
            if (stall.id === selectedStallId) {
              div.classList.add("selected");
            }
            div.dataset.stallId = stall.id;

            const lane = stall.lane ?? "?";
            const pts = stall.points.length;

            const left = document.createElement("span");
            left.textContent = `#${stall.id}`;

            const right = document.createElement("span");
            right.innerHTML = `<small>Lane ${lane} • ${pts} pts</small>`;

            div.appendChild(left);
            div.appendChild(right);

            div.addEventListener("click", () => {
              selectedStallId =
                selectedStallId === stall.id ? null : stall.id;
              refreshStallList();
              drawAll();
            });

            container.appendChild(div);
          });
      }

      function undoPoint() {
        if (currentPoints.length > 0) {
          currentPoints.pop();
          drawAll();
        }
      }

      function clearCurrent() {
        currentPoints = [];
        drawAll();
      }

      function finishStall() {
        if (currentPoints.length < 3) {
          setStatus(
            "A stall needs at least 3 points. Add more points first.",
            "error"
          );
          return;
        }
        const laneInput = document.getElementById("laneSelect");
        let laneVal = parseInt(laneInput.value, 10);
        if (Number.isNaN(laneVal) || laneVal <= 0) laneVal = 1;

        const stallId = nextStallId++;
        stalls.push({
          id: stallId,
          lane: laneVal,
          points: currentPoints.map((p) => ({ x: p.x, y: p.y }))
        });

        currentPoints = [];
        selectedStallId = stallId;
        refreshStallList();
        drawAll();
        setStatus(`Stall #${stallId} added on Lane ${laneVal}.`, "ok");
      }

      function deleteSelectedStall() {
        if (!selectedStallId) {
          setStatus("No stall selected to delete.", "error");
          return;
        }
        stalls = stalls.filter((s) => s.id !== selectedStallId);
        selectedStallId = null;
        refreshStallList();
        drawAll();
        setStatus("Stall deleted.", "ok");
      }

      function toDiskFormat() {
        // Convert stalls to { id, lane, points: [[x, y], ...] }
        return {
          stalls: stalls.map((stall) => ({
            id: stall.id,
            lane: stall.lane,
            points: stall.points.map((p) => [
              Math.round(p.x),
              Math.round(p.y)
            ])
          }))
        };
      }

      function fromDiskFormat(data) {
        const arr = (data && data.stalls) || [];
        stalls = arr.map((s) => {
          const pts = (s.points || []).map((p) => ({
            x: p[0],
            y: p[1]
          }));
          return {
            id: s.id,
            lane: s.lane,
            points: pts
          };
        });
        // Determine nextStallId
        let maxId = 0;
        for (const s of stalls) {
          if (typeof s.id === "number" && s.id > maxId) {
            maxId = s.id;
          }
        }
        nextStallId = maxId + 1;
      }

      async function loadConfig() {
        try {
          setStatus("Loading existing config…");
          const resp = await fetch(apiConfigUrl);
          if (!resp.ok) {
            setStatus("No existing config found (starting fresh).", "error");
            stalls = [];
            nextStallId = 1;
            refreshStallList();
            drawAll();
            return;
          }
          const data = await resp.json();
          fromDiskFormat(data);
          refreshStallList();
          drawAll();
          setStatus("Loaded existing config.", "ok");
        } catch (err) {
          console.error("Error loading config:", err);
          setStatus("Error loading config from server.", "error");
        }
      }

      async function saveConfig() {
        try {
          setStatus("Saving config to disk…");
          const payload = toDiskFormat();
          const resp = await fetch(apiConfigUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(payload)
          });

          if (!resp.ok) {
            setStatus("Failed to save config.", "error");
            return;
          }
          setStatus("Config saved successfully.", "ok");
        } catch (err) {
          console.error("Error saving config:", err);
          setStatus("Error saving config.", "error");
        }
      }

      function init() {
        imgEl = document.getElementById("liveFeed");
        canvas = document.getElementById("configCanvas");
        ctx = canvas.getContext("2d");

        setupCanvasFromImage();

        /* block clicks outside image */
canvas.addEventListener("click", function (evt) {
  const rect = imgEl.getBoundingClientRect();

  // If click is NOT inside image, ignore it
  if (
    evt.clientX < rect.left ||
    evt.clientX > rect.right ||
    evt.clientY < rect.top ||
    evt.clientY > rect.bottom
  ) {
    return;
  }

  onCanvasClick(evt);
});


        document
          .getElementById("btnUndoPoint")
          .addEventListener("click", undoPoint);
        document
          .getElementById("btnClearCurrent")
          .addEventListener("click", clearCurrent);
        document
          .getElementById("btnFinishStall")
          .addEventListener("click", finishStall);
        document
          .getElementById("btnDeleteStall")
          .addEventListener("click", deleteSelectedStall);
        document
          .getElementById("btnSaveConfig")
          .addEventListener("click", saveConfig);

        loadConfig();
      }

      // === Flip toggle logic ===
      async function loadFlip() {
        try {
          const resp = await fetch(`/api/lots/${lotId}`);
          const data = await resp.json();
          const flip = data.flip ? 1 : 0;
          document.getElementById("flipState").textContent = flip ? "ON" : "OFF";
        } catch(e) {
          console.error(e);
        }
      }

      async function toggleFlip() {
        try {
          const current = document.getElementById("flipState").textContent === "ON" ? 1 : 0;
          const newVal = current ? 0 : 1;
          await fetch(`/api/lots/${lotId}/flip`, {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({ flip: newVal })
          });
          document.getElementById("flipState").textContent = newVal ? "ON" : "OFF";
          imgEl.src = `/frame-latest/${lotId}?t=${Date.now()}`;


        } catch(e) {
          console.error(e);
        }
      }

      document.getElementById("flipToggle").addEventListener("click", toggleFlip);
      loadFlip();

      document.addEventListener("DOMContentLoaded", init);
    })();
  </script>
</body>
</html>
